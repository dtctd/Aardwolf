<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Thursday, October 30, 2008, 7:39 PM -->
<!-- MuClient version 4.33 -->

<!-- Plugin "Aardwolf_exits_detector" generated by Plugin Wizard -->

<muclient>
  <plugin
      name="Aardwolf_srun_swalec"
      id="24c24132ab326dc05b4942ed"
      language="Lua"
      purpose="Speedwalk enchancements for aardwolf"
      author = "swalec"
      save_state = "y"
      date_written="2008-12-26 19:38:12"
      requires="4.33"
      version="1.0"
      >


    <!--
        Copyright (c) 2008 Swalec

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

    -->

    <description trim="y">

This plugin is should be considered late beta. I use it all the time and it
works well, but it hasn't had a lot of testing outside of my environment.

The srun plugin is supplements Aardwolf's own runto command, but with three advantages.
First srun keeps a track of where you are and can therefore work from anywhere
at all. Second, srun allows you to add new locations besides those given from
the mud, and new directions between these locations. This includes the use of
portals. Finally, srun calculates the shortest path between the locations. 

The documentation is a bit long for here; it is hosted on 

http://swalec.wordpress.com

License:

Copyright 2008 Swalec

This is released under the MIT license, which is the same license as Lua.

    </description>

  </plugin>


  <aliases>
    <alias
        script="OnHelp"
        match="Aardwolf_srun_swalec:help"
        enabled="y"
        >
    </alias>
  </aliases>

  <script>
    <![CDATA[
             function OnHelp ()
             world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
             end
    ]]>
  </script> 


  <aliases>
    <!--alias
        enabled = "y"
        match = "run *"
        script = "run"
        >
        </alias-->

    <alias
        enabled = "y"
        match = "runto *"
        script = "runto"
        />
    
    <alias
        enabled = "y"
        match = "rerun"
        script = "rerun"
        />
    
    <alias 
        enabled = "y"
        name="guesscommand" 
        match = "srun guess" 
        script = "guess" 
        />
    
    <alias
        enabled = "y"
        match = "srun showpath *"
        script = "showpath"
        />

    <alias
        enabled = "y"
        match = "srun runhist"
        script = "runhist"
        />

    <alias 
        enabled = "y"
        match = "srun mark"
        script = "mark"
        />
    
    <alias
        enabled = "y"
        match = "srun return"
        script = "mark_return"
        />

    <alias
        enabled = "y"
        match = "srun runtohist"
        script = "runtohist"
        />
 
    <alias
        enabled = "y"
        match = "srun set_clan_recall *"
        script = "set_clan_recall_to_recall"
        />

    <alias
        enabled="y"
        match = "srun set_prerun *"
        script = "set_prerun" 
        />

    <alias
        enabled="y"
        match = "srun set_tier *"
        script = "set_tier" 
        />
    
    <alias 
        enabled = "y"
        match = "srun add_location *"
        script = "add_location_alias"
        />

    <alias
        enabled ="y"
        match = "srun add_portal *"
        script = "add_portal_alias" 
        />

    <alias
        enabled = "y"
        match = "srun add_direction *"
        script = "add_direction_alias"
        />
    
    <alias
        enabled = "y"
        match = "srun add_runto *"
        script = "add_runto_alias"
        />

    <alias 
        enabled = "y"
        match = "srun list *"
        script = "list_alias"
        />
    
    <alias 
        enabled = "y"
        match = "srun delete *" 
        script = "delete_alias" 
        />
    
    <alias
        enabled = "y"
        match = "srun where *"
        script = "where"/>
    
    <alias
        enabled = "y"
        match = "srun clearall"
        script = "clearall"
        />

    <alias 
        enabled = "y"
        match = "srun read_speedwalk"
        script = "read_speedwalk"
        />
    
    <alias 
        enabled = "y"
        match = "srun continue"
        script = "continue_alias"
        />

    <alias 
        enabled = "y"
        match = "srun pause"
        script = "continue_alias"
        />
    

    <alias 
        enabled = "y"
        match = "srun iwuvaard"
        script = "iwuvaard_init"
        />

    <alias 
        enabled = "y"
        match = "srun iwuv_block *"
        script = "iwuvaard_block"
        />

    <alias 
        enabled = "y"
        match = "srun print *"
        script = "srun_print"
        />

    <alias 
        enabled = "y"
        match = "srun dumpall"
        script = "dumpall"
        />

    <alias 
        enabled = "y"
        match = "srun dumpinfo"
        script = "dumpinfo"
        />

    <alias
        enabled = "y"
        match = "srun help"
        script = "OnHelp"
        />

    <!-- catch all to block the irritating social that happens otherwise -->
    <alias
        enabled = "y"
        match = "srun *"
        script = "OnShortHelp"
        sequence = "10000"
        />

  </aliases>

  <triggers>

    <trigger
        enabled="n"
        match="{speedwalkstart}"
        script="speedwalk_redirect"
        name="start"
        omit_from_output="y"
        sequence="100"
        regexp="y" 
        />
    
    <trigger
        enabled="n"
        match="*"
        name="line"
        script="speedwalk_redirect"
        omit_from_output="y"
        sequence="10"
        />


    <trigger
        enabled = "y"
        match  = "WHOOOOOOOOOOOOSH!"
        regexp = "n"
        sequence = "10"
        keep_evaluating = "y"
        script = "portal_use"
        />
    
    <trigger
        enabled = "y"
        match = "Running to: *"
        script = "running_to"
        />
    
    
    <!-- error handling triggers -->
    <trigger
        enabled="y"
        match = "Alas, you cannot go that way."
        script = "process_error"
        />

    <trigger
        enabled = "y"
        match = "You can only fly there."
        script = "process_error"
        >
    </trigger>

    <trigger
        enabled = "y"
        match = "You are trapped in quicksand."
        sequence = "100"
        script = "process_error"
        >
    </trigger>
    
    <trigger
        enabled = "y"
        match = "^The (.*) is locked and you do not have a key.$"
        regexp= "y"
        script = "process_error"
        >
    </trigger>

    <trigger
        enabled="y" 
        match = "Magic walls bounce you back."
        script = "process_error"
        />

    <trigger
        enabled="y" 
        match = "You are entangled in an invisible web!"
        script = "process_error"
        />

    <trigger
        enabled="y" 
        match = "You cannot recall from this room."
        script = "process_error"
        />

    
    <!-- to my knowledge, the aardh is the only non continent area. It's
         coords location (-1) doesn't match the regexp -->
    <trigger 
        enabled = "y"
        omit_from_output="y"
        script = "updatelocation_aardh"
        sequence = "100"
        match = "{coords}-1"
        />
      
    <trigger
        enabled="y" 
        omit_from_output="y"
        regexp="y"
        script="updatelocation"
        sequence="50"
        match="^\{coords\}(?&lt;zone&gt;\d+)\,(?&lt;x&gt;\d+)\,(?&lt;y&gt;\d+)$"
        />
      

    <trigger
        enabled = "y"
        script = "guess"
        name = "guesstag"
        omit_from_output= "y"        
        match = "{srunguess}"
        />

    <trigger
        enabled = "y"
        script = "runtoend"
        omit_from_output= "y"        
        match = "{srunend} *"
        />

    <trigger
        enabled = "y"
        match = "*is not an area keyword or a find location in this area."
        script = "process_error"
        />
    <trigger 
        enabled = "y"
        match = "There are multiple matches for *. Use one of the following keywords:"
        script = "process_error"
        />
    
  </triggers>

  <script>
    <![CDATA[



require "checkplugin"
require "var"
require "serialize"

datestamp = "2010_06_27_15_07"



--
-- graph implementation for srun plugin
--


--
-- core data structures. 
--

-- 
-- There are three core objects; locations and routes (nodes and edges) and a
-- single container hash which contains all these (and a few other values). 
--
-- We use the single container hash as a single point of entry; this should
-- made serializiation more straight forward. 
--
-- In my hands, serialisation is a bit problematic; it appears that table keys
-- cannot themselves be tables (this might be a limitation of my test
-- serialisation code, rather the mushclient code). So, I have had to add an
-- ID to locations which I can use as a numeric hash.  
--


-- central storage structure.

-- an ID for the graph strucure version -- bump this up everytime a
-- potentially incompatible change is made. 
srun_graph_structure_version = 5


-- all data is stored here, so we have a single mud var to serialise.
srun_config = nil

-- srun_config_cache will carry a number of tables some for optimisation.
function get_srun_config()
   if( not srun_config ) then
      srun_config = {}
      
      -- location max id's; we need an id for each location for indexing
      -- purposes. Because, we can remove locations, we only guarentee that
      -- there is not id larger than this; not that this is the biggest id,
      -- nor that this is the number of locations.
      srun_config.location_max_id = 0
      
      -- location, stored in a hash
      srun_config.location = {}
      
      -- all portals in an array
      srun_config.portal = {}

      -- routes, stored in a hash. This is going to be denormalised, as could
      -- also get the information from the locations.
      srun_config.route = {}
      
      -- runto names - hash, keyed on a name or names, value, an element of
      -- the srun.location array
      srun_config.runto_name = {}
      
      -- locations stored against runto names. 
      srun_config.area_name = {}
      
      -- and the version number
      srun_config.version = srun_graph_structure_version

      -- init portal and unknown
      get_recall_location()
      get_unknown_location()
      get_aardh_location()
      get_clan_recall_location()
      get_aardl_location()

      rebuild_conf()
   end

   return srun_config
end

function clear_conf()
   srun_config = nil
end
--
--  check function 
--
function check_graph_version()
   return get_srun_config().version == srun_graph_structure_version
end

--
-- accessor functions
-- 
function get_locations()
   return get_srun_config().location
end

function get_locations_size()
   return # get_locations()
end

function is_known_location( location )
   return get_locations()[ location ]
end

function get_routes()
   return get_srun_config().route
end

function get_routes_size()
   return # get_routes()
end

function get_runto_names()
   return get_srun_config().runto_name
end

function get_speedwalk_from_mud()
   return get_srun_config().speedwalk_from_mud
end

function get_location_for_name( name )
   return get_runto_names()[ name ]
end

-- 
-- mutor functions
-- 

-- add a runto_name to a location
function add_runto_name( location, runto_name )
   get_runto_names()[ runto_name ] = location   
   return location, runto_name
end


function add_direction( fromlocation, direction, tolocation )
   
   error_info = tostring( fromlocation ) .. tostring( direction ) .. tostring( tolocation )
   -- fail early
   assert( fromlocation, "fromlocation cannot be nil:" .. error_info )
   assert( direction, "direction cannot be nil:" .. error_info )
   assert( tolocation, "tolocation cannot be nil:" .. error_info )
   assert( fromlocation.type == "location", 
           "from location argument must be a location" )
   assert( tolocation.type == "location",
           "to location argument must be a location" )
   
   -- we need to check whether any of the outgoing edges are subroutes of
   -- direction, so that we can normalise the structure. 
   local edges_to_remove = {}

   for _, route in pairs( fromlocation.outroutes ) do
      local second_direction = route.direction
      
      --print( "add:", location_print_string( fromlocation ), 
      --location_print_string( tolocation.area ) )
      assert( not direction_equals( direction, second_direction ),
              "adding two directions which are the same" )
      
      local subtract
      if( # direction > # second_direction ) then
         
         subtract = direction_subtract( direction, second_direction )
         if( subtract ) then
            
            -- I don't think that this can happen, although I may have got it
            -- wrong. 
            assert( # edges_to_remove == 0, 
                    "This shouldn't happen" )
            
            -- so, we already have an outgoing edge of fromlocation which
            -- covers part of the route, so instead add the shorter direction
            -- between the existing outgoing node
            return add_direction( route.to, subtract, tolocation )         
         end 
      else
         
         -- this bit is bugged, but I don't know how
         -- hmmm         
         subtract = direction_subtract( second_direction, direction )
         if( subtract ) then
            -- need to work out whether ipairs is stable to change at some
            --point.
            remove_route( route )
            -- so we remove the over all route and add two shorter ones. 
            add_direction( tolocation, subtract, route.to )
            return add_direction( fromlocation, direction, tolocation )
         end
      end
   end
   
   -- remove any extra routes that we no longer need
   -- for _, route in ipairs( edges_to_remove ) do
   --    remove_route( route )
   --    print( "Removing route", location_print_string( route.from ), location_print_string( route.to ) )
   -- end
   
   -- check whether we really want to do this first
   local route = route_new()
   route.direction = direction   
   
   route.from = fromlocation
   route.to = tolocation
   
   -- add to from and to locations
   fromlocation.outroutes[ tolocation.id ] = route
   tolocation.inroutes[ fromlocation.id ] = route 

   return route
end


function remove_route( route )
   assert( (route.type == "route" ), "remove_route requires a route" )
   array_remove( get_routes(), route )
   
   assert( route.from.outroutes[ route.to.id ], 
           "can't remove route: outroute not found" )
   assert( route.to.inroutes[ route.from.id ], 
           "can't remove route: inroute not found" )
   route.from.outroutes[ route.to.id ] = nil
   route.to.inroutes[ route.from.id ] = nil
end


local location_mt = {}
location_mt.__tostring = 
   function (this)
      local title = this.title or "no title"
      local area = this.area_name or "no area" 
      local x = this.x or "no x"
      local y = this.y or "no y"
      
      return "Location: Title - \"" .. title .. 
         "\" x - " .. x .. " y - " .. y
   end


--
--  Location data structure
--
function location_new()
   local location = {}
   setmetatable( location, location_mt )
   location.type = "location"
   
   -- create a new ID for this location, which we will use for the next two
   -- tables.
   location.id = get_srun_config().location_max_id 
   local config = get_srun_config()
   config.location_max_id = 
      config.location_max_id + 1

   -- routes from this edge. This hash is keyed on the ID of the location on
   -- which the route finishes. This enables us to ask whether one location is
   -- linked to another in constant time, rather than with linear search. 
   location.outroutes = {}
   -- like outroutes, but keyed on the id of the location at which the route
   location.inroutes = {}
   -- incoming portals -- movable portals (those which can work from anywhere)
   -- which terminate at this location
   location.inportals = {}

   -- room title of this location.
   -- this will be pulled from the mud
   location.title = nil
   
   -- area name
   -- this is pulled from the mud
   location.area_name = nil

   -- given name -- this is not a speedwalk name, but a short name for
   -- locations which are created, rather than those sw's pulled from the mud.
   location.given_name = nil
   
   -- speedwalk direction -- the raw direction pulled straight from the mud.
   -- This maybe nil, if it's not a mud location.
   location.mud_speedwalk = nil

   -- nearest coordinates of this location.
   location.x = "Unknown"
   location.y = "Unknown"
   location.zone = "Unknown"


   -- is this area no portal?
   location.no_portal = false
   
   -- is this area no portal?
   location.no_recall = false
   
   -- store locations
   -- this should be a hash rather than an array, so we can do remove
   -- operations easily, but this serialize function doesn't appear to work
   -- with tables a keys. 
   table.insert( get_locations(),
                 location )

   return location
end

function location_outroutes( location )
   return location.outroutes
end

function location_inroutes( location )
   return location.inroutes
end

function location_title( location )
   return location.title
end


--
-- Route data structure
--
function route_new()
   local route = {}
   
   route.type = "route"
   
   -- start and finish locations. 
   route.from = nil
   route.to = nil
   
   -- an array with one movement per element (so 4n would be n, n, n, n)
   route.direction = {}
   
   -- a distance, or nil. Nil means that the distance can be calculated from
   -- the array (by counting the number of steps). 
   route.distance = nil
   
   -- requirements for route
   -- these are not uncovered yet..
   route.passdoor = false
   route.fly = false
   route.levellock = 1
   
   table.insert( get_routes(), route )

   return route
end

-- accessors
function route_from( route )
   return route.from
end

function route_to( route )
   return route.to
end

function route_direction( route )
   return route.direction
end

--
-- portals
-- 
function portal_new()
   local portal = {}
   portal.type = "portal" 
   
   portal.alias = ""
   portal.tolocation = {}
   portal.level = 1
   
   -- a reasonable default -- it takes two or three commands to use a portal
   --(hold, enter) and these take longer than an equivalent speedwalk. 
   portal.weight = 5
   
   -- this portal is of the recall type -- so it will still work 
   -- even if the area cannot be normally portalled out of. 
   portal.is_recall_type = false
   
   table.insert( get_srun_config().portal, portal )

   return portal
end

-- 
-- add a portal to the location 
--
function add_portal( portal_alias, tolocation )
   local portal = portal_new() 
   
   portal.tolocation = tolocation
   portal.alias = portal_alias
   table.insert( tolocation.inportals, portal )
   return portal
end


-- 
-- direction
-- 
local direction_mt = {}
direction_mt.__tostring = 
   function (this)
      return "Direction: "
   end

function direction_new()
   local direction = {}
   setmetatable( direction, direction_mt )
   direction.type = "direction"
   return direction   
end


--
-- This takes a speedwalk string of the form 4n3u and returns an array of
-- directions of the form, n,n,n,n,u,u,u.
-- 
function speedwalk_string_to_direction( speedwalk_string )
   local direction = direction_new()
   
   local number_stack = ""
   for i = 1, string.len( speedwalk_string ) do
      local char = string.sub( speedwalk_string, i, i )
      
      if( tonumber( char ) ) then
         number_stack = number_stack .. char;
      else
         assert( string.match( char, "[neswud]+" ) )
         
         -- loop if we need to, or just add direction
         for j = 1, (tonumber( number_stack ) 
                  or 1 )
         do
            table.insert( direction, char )
         end
         number_stack = ""
      end
   end
   return direction
end



--
-- this takes a direction and turns it back again into a speedwalk string
--
function direction_to_speedwalk_string( direction )
   assert( direction.type == "direction", 
           "Only directions are allowed:  not " .. direction.type )
   
   local retn = ""
   local last_sw_chunk = {}
   
   for _, v in ipairs( direction ) do
      -- it's a direction so store it
      if( string.len( v ) == 1 and string.match( v, "[newsud]" ) ) then
         table.insert( last_sw_chunk, v )
      else
         -- it's something else, append last_sw_chunk and this
         if( # last_sw_chunk > 0 ) then
            local directions = 
               speedwalk_direction_only_to_string( last_sw_chunk )
            last_sw_chunk = {}
            retn = retn .. "run " .. directions .. ";"
         end
         retn = retn .. v .. ";"
      end
   end
   
   -- add last..
   if( # last_sw_chunk > 0 ) then
      local directions = 
         speedwalk_direction_only_to_string( last_sw_chunk )
      last_sw_chunk = {}
      retn = retn .. "run " .. directions .. ";"
   end
   
   -- chop of last ";"
   return string.sub( retn, 1, -2 )
end

-- takes an array of directions (n,e,e,s,w,w,w) and turns them into a string
-- (n2es3w)

function speedwalk_direction_only_to_string( direction )
   local retn = ""
   local last_direction = nil
   local last_direction_count = 0
   
   local append = 
      function( last_direction, last_direction_count, retn ) 
         if( last_direction_count > 0 ) then 
            -- string or nothing if it's 0
            local direction_count_string =                
               last_direction_count == 1 and "" or last_direction_count
            return retn .. direction_count_string ..
               last_direction
         end
         return retn
      end
   
   for _,v in ipairs( direction ) do
      -- just store this information
      if( v == last_direction ) then
         last_direction_count = last_direction_count + 1
         -- print( "v = last_direction", last_direction_count )
      else
         -- pop the last direction and count onto retn 
         retn = append( last_direction, last_direction_count, retn )
         -- remember this as the last direction
         last_direction_count = 1
         last_direction = v
      end
   end
   
   -- make sure we add the last
   retn = append( last_direction, last_direction_count, retn )
   return retn
end

-- takes a full speedwalk of form 
-- run 3e4n;open w;w4n and converts it too
-- e,e,e,open w,w,n,n,n,n 
-- this function will take sw either of "run 3e" or "3e"
function full_speedwalk_string_to_direction( speedwalk_string )
   
   local elements = split( speedwalk_string, ";" )
   local retn = direction_new()
   
   for _, v in ipairs( elements ) do
      
      -- chop off "run" 
      if( string.sub( v, 1, 3 ) == "run" ) then
         v = string.sub( v, 5 )
      end
      
      if( 
         string.match( v, "[newsud0-9]+" ) and 
         string.len( v ) 
      == string.len( string.match( v, "[newsud0-9]+" ) ) ) then
         local sw = speedwalk_string_to_direction( v )
         for _, v in ipairs( sw ) do
            table.insert( retn, v )
         end
      else 
         table.insert( retn, v )
      end
   end
   return retn
end


-- take an output line from the speedwalk_command
-- and turn it into an area name and a direciton
function process_speedwalk_command_output_line( line )
   local dest = split( line, "run " )
   
   local area_name;
   local direction;
   
   -- dest will be nil if it's not a speedwalk line. 
   if( # dest > 1 ) then 
      area_name = trim( dest[ 1 ] )
      table.remove( dest, 1 )
      local concat_string  = "";
      for _, v in ipairs( dest ) do
         concat_string =  concat_string .. v
      end      
      direction = full_speedwalk_string_to_direction( concat_string )
      return area_name, direction
   end
end



function split(str, pat)
   local t = {}  -- NOTE: use {n = 0} in Lua-5.0
   local fpat = "(.-)" .. pat
   local last_end = 1
   local s, e, cap = str:find(fpat, 1)
   while s do
      if s ~= 1 or cap ~= "" then
	 table.insert(t,cap)
      end
      last_end = e+1
      s, e, cap = str:find(fpat, last_end)
   end
   if last_end <= #str then
      cap = str:sub(last_end)
      table.insert(t, cap)
   end
   return t
end

-- trim leading and trailing spaces from a string
function trim (s)
   return (string.gsub (s, "^%s*(.-)%s*$", "%1"))
end -- trim


-- direction manipulation

-- if longer starts with shorter, return the directions left over. 
-- if longer does not start with shorter return nil
function direction_subtract( longer, shorter )
   if( not direction_starts_with( longer, shorter ) ) then
      return false
   end
   
   local retn = direction_new()
   for i = # shorter + 1, # longer do
      table.insert( retn, longer[ i ] )
   end

   return retn
end

function direction_starts_with( longer, shorter )
   for i = 1,# shorter do 
      if( longer[ i ] ~= shorter[ i ] ) then 
         return false
      end
   end
   
   return true
end

function direction_equals( a, b )
   if( # a ~= # b ) then 
      return false
   end

   return direction_starts_with( a, b )
end


--
-- recall 
-- 
-- Hard Code this in, or we have to harvest from recall before we can pull out
-- speedwalks.
--
function get_aardh_location() 
   local aardh = get_runto_names().aardh

   if( aardh ) then 
      return aardh
   end

   aardh = location_new()
   aardh.title = "The Aardwolf Plaza Hotel (G)"
   -- the aardh has a coords tags of just -1, and is treated specially.
   aardh.x = -1 
   aardh.y = -1
   aardh.zone = -1
   
   -- can't portal out of aardh
   aardh.no_portal = true

   local direction = direction_new()
   direction[ 1 ] = "d"
   add_direction( aardh, direction, get_recall_location() )
   add_runto_name( aardh, "aardh" )
end

function get_aardl_location() 
   local aardl = get_runto_names().aardl

   if( aardl ) then 
      return aardl
   end

   aardl = location_new()
   aardl.title = "The Luxury \"Suite\" (G)"
   -- the aardh has a coords tags of just -1, and is treated specially.
   aardl.x = -1 
   aardl.y = -1
   aardl.zone = -1
   
   -- can't portal out of aardh
   aardl.no_portal = true

   local direction = direction_new()
   direction[ 1 ] = "d"
   add_direction( aardl, direction, get_recall_location() )
   
   local direction = direction_new()
   direction[ 1 ] = "enter elevator"
   add_direction( aardl, direction, get_aardh_location() )
   
   add_runto_name( aardl, "aardl" )
end


function get_recall_location()
   local recall = get_runto_names().recall

   if( recall ) then 
      return recall
   end

   -- initialize recall
   recall = location_new()
   recall.title = "The Grand City of Aylor (G)"
   recall.area = "recall"
   recall.x = 30
   recall.y = 20
   recall.zone = 0
   
   -- if recall location, neither is the recall spell, so add it. this is
   -- broken -- recall may go back to recall at aylor but it might also go to
   -- the clan recall. 
   --local recall_spell = 
   --   add_portal( "recall", recall )
   --recall_spell.weight = 500
   -- init clan recall at the same time
  
   -- lots of runto names...
   add_runto_name( recall, "recall" )
   add_runto_name( recall, "recl"  )
   add_runto_name( recall, "aylor" )
   return recall
end


-- hard coded... put in an option to set the clan recall direction. If that is
-- nil, just return recall.
function get_clan_recall_location()
   local clanrecall = get_runto_names().clanrecall

   if( clanrecall ) then 
      return clanrecall
   end

   -- initialize recall
   clanrecall = location_new()
   clanrecall.given_name = "Clan Recall"


   -- if we are getting the clan recall for the first time, then we also need
   -- the recall portal. If there is no clan recall, there should be a nop
   -- direction back to recall.
   recall_spell = 
      add_portal( "recall", clanrecall )
   recall_spell.weight = 500
   recall_spell.is_recall_type = true

   add_runto_name( clanrecall, "crecall" )
   
   -- there's always a crecall location, but there is no reason you have to be
   -- able to away from there. 
   if( get_srun_info().clan_recall_to_recall ) then 
      local direction = 
         speedwalk_string_to_direction( get_srun_info().clan_recall_to_recall )
   
      add_direction( clanrecall, direction, get_recall_location() )
   else
      add_direction( clanrecall, full_speedwalk_string_to_direction( "nop" ), 
                     get_recall_location() )
   end

   return recall
end

recall_spell = nil
function get_recall_spell_portal() 
   if( recall_spell ) then
      return recall_spell
   end
   
   get_clan_recall()
   return recall_spell
end

function get_unknown_location()
   local unknown = get_runto_names().unknown
   
   if( unknown ) then 
      return unknown 
   end
   
   unknown = location_new()
   unknown.title = "Unknown Location" 
   unknown.x = 0
   unknown.y = 0
   unknown.zone = "Unknown"
   
   add_runto_name( unknown, "unknown" )
   
   return unknown
end

-- array manipulation
function array_remove( array, element )
   for i, v in ipairs( array ) do
      if( element == v ) then
         return table.remove( array, i )
      end
   end
end

function location_print_string( location )
   return location.given_name or location.area 
      or location.title or location.id or "No Name"
end

-- this needs to be integrated a bit
function pretty_location_routes( location, already_printed, print_indent )
   
   local retn = ""
   
   already_printed = already_printed or {}
   print_indent = print_indent or ""
   
   local location_ps = location_print_string( location )
   
   print( "Checking ", location_ps )
   
   retn = retn .. print_indent .. " " .. location_ps .. "\n"
   if( already_printed[ location ] ) then
      return retn .. print_indent .. "\t(term)\n"
   end

   already_printed[ location ] = true
   
   retn = retn .. print_indent .. "-->"
   print_indent = print_indent .. "  "
   

   for i,v in pairs( location_outroutes( location ) ) do
      print( "Should be checking", v.to )
      retn = retn .. pretty_location_routes( v.to, already_printed, print_indent )
   end
   
   return retn
end


function test_print_location( location, already_printed, print_indent )
   
   already_printed = already_printed or {}
   print_indent = print_indent or ""
   
   io.write( print_indent, location.title )
   if( already_printed[ location ] ) then
      io.write( "(term)" )
      return
   end
   already_printed[ location ] = true
   
   print( "-->" )
   print_indent = print_indent .. "     "
   
   for i, v in pairs( location.outroutes ) do
      test_print_location( v.to, already_printed, print_indent )
   end
end


function dot_string( )
   local already_done_location = {}
   
   local dot_string = "digraph G {\n"
   
   for i, v in pairs( get_locations() ) do
      dot_string = dot_string .. dot_string_impl( v )
   end

   dot_string = dot_string .. "}"
   return dot_string
end

function dot_string_impl( location )
   
   local dot_string = ""
   
   local loc_from_ps = location_print_string( location )
   
   for i,v in pairs( location.outroutes ) do
      local loc_to_ps = location_print_string( v.to )
      dot_string = dot_string .. loc_from_ps
         .. "->" .. loc_to_ps .. ";\n"
   end
   return dot_string
end



--
-- Think that the problem is that he us running "u" from aardh and the trying to re-enter the amulet, which isn't working
-- because it's no portal
-- He has portal wear location and equips amulet the entire time, so enter should just work. 
-- need to check on this. 
-- 


-- Error from Wyza
-- running to: aardh
-- enter
-- echo {srunend} srunto
-- WHOOOOOOOOOOOOSH!
-- best weapon: (303173)
-- take (303173) from (296530)
-- second (303173)
-- The Aardwolf Plaza Hotel (G)
-- [Exits: north east south west up down]

-- ...cut...

-- Srun: runto complete
-- New details discovered
-- ID: 243
-- Area name: nil
-- Room title:  
-- Given Name:  aardh
-- Run-time error
-- Plugin: Aardwolf_srun_swalec (called from world: Aardwolf)
-- Function/Sub: runtoend called by trigger
-- Reason: processing trigger ""
-- [string "Plugin"]:1885: attempt to concatenate field 'x' (a nil value)
-- stack traceback:
--         [string "Plugin"]:1885: in function 'print_location'
--         [string "Plugin"]:1359: in function 'grab_mud_location_details'
--         [string "Plugin"]:1310: in function <[string "Plugin"]:1250>
-- Error context in script:
-- 1881 :    print( "ID:", location.id )
-- 1882 :    print( "Area name:", location.area )
-- 1883 :    print( "Room title: ", location.title )
-- 1884 :    print( "Given Name: ", location.given_name )
-- 1885*:    print( "Coords:", location.x .. ",", location.y .. ",",
--  location.zone )
-- 1886 :    print( "There are", outr, "outgoing routes" )
-- 1887 :    print( "There are", inr, "incoming routes" )
-- 1888 :    print( "There are", inp, "portals ending here" )
-- 1889 : end




--
-- This is where we currently think we are. 
--
local current_believed_loc = nil

function current_believed_location( location )
   -- get...
   if( location == nil ) then
      return current_believed_loc
         or get_unknown_location() 
   end

   -- set...
   current_believed_loc = location
end

--
-- return the last known location or recall if no where is known
--
local last_known_loc = nil

function last_known_location()
   if( current_believed_location() == get_unknown_location() ) then
      if( last_known_loc ) then 
         return last_known_loc
      else
         return get_recall_location() 
      end
   end
   
   return current_believed_location()
end

--
-- If we have just used a system runto command (that is sent "runto" to the
-- mud), then what is the string name of the area to which we are running. 
--
local current_running_to_formal_title = ""

-- 
-- If we are expecting a runto tag to occur, but there is a movement error.  
--
local runto_error = false



--
-- If we are currently in a run of any sort.
--
local currently_running_p = false


-- 
-- The current coordinates (x, y and zone) and roomname from the mud. 
--
local coord = {}
local roomname = ""
local previousroomname = ""

--
-- Command histories
--
local runhistory = {}
local runtohistory = {}

--
-- pause support -- stuff remaining after pause
-- 
local commands_stack = nil
local commands_specials = 
   {["pause"] = 1, ["wait"] = 1,
    ["nop"] = 1,
    ["automazepause"] = 1, 
    ["autohuntpause"] = 1,
 }

--
-- Aliases and supporting functions
--


--
-- Sends a tag to the mud which wil be echoed back, which allows us to
-- determine when the run has finished.
-- 
function send_runend( type )
   Send( "echo {srunend} " .. type )
end

--
-- Overrides the system "run" command just to add a command history
--
function run( name, line, wildcards )
   table.insert( runhistory, wildcards[ 1 ] )
   Send( line )
   send_runend( "run" )
end

-- 
-- runto the last place that we ran to. 
--
function rerun( name, line, wildcards )
   runto( "", "", runtohistory[ 1 ] )
end

-- 
-- Overrides the system "runto" command. Main entry point for this plugin. 
--
function runto( name, line, wildcards )
   local location = wildcards [ 1 ]

   -- store history
   table.insert( runtohistory, location )
   
   -- are we trying to go where we already are
   local end_location = get_location_for_name( location )
   
   if( end_location == current_believed_location() ) then
      sprint( "Already at ", location )
      return
   end

   -- do we know the location that the plugin has been asked to runto. If so,
   -- then find the shortest path and run.
   if( end_location ) then
      
      -- tell the user
      local loc_string = location_print_string( end_location )
      print( "Srunning to:", loc_string ) 
      
      -- do the run
      runto_location( end_location )
      return
   end

   -- either a mistake or we just don't know the location abbreviation 

   -- are we at recall?
   if( current_believed_location()
    == get_recall_location() ) then 

      -- just use the system runto and let it handle mistakes
      runto_system( location )
   else
      
      -- is the user repeated exactly the same command that they just used. If
      -- so, do a recall and then the runto
      if( last_runto_unknown and
          last_runto_unknown_location == location ) then
         -- do recall first
         last_runto_unknown=false
         runto_location( get_recall_location() )
         runto_system( location )
      else
         -- tell the user they are must be at recall, and tell them how to get
         -- srun to do that.
         last_runto_unknown=true
         last_runto_unknown_location=location
         
         sprint( "Location is not known to srun: ", location )
         sprint( "Repeat command to retry from recall" )
      end
   end
end


--
-- get the system to do a runto
--
function runto_system( location )
   -- broadcast start
   BroadcastPlugin( 2, "" )
   
   Send( "runto " .. location )
   send_runend( "sysrunto" )
   currently_running_p = true
end


-- 
-- runto a location for ourself
--
function runto_location( end_location )

   if( not (pre_run() == "") ) then
      print( "Prerun:", pre_run() )
      Execute( pre_run() )
   end

   -- place the route onto the stack
   command_stack = shortest_path_to_list( current_believed_location(), 
                                          end_location )
   
   print( "runto_location", # command_stack )
   if( command_stack_is_empty() ) then 
      -- there is no route, so complain
      sprint( "Can't find route" )
      return
   else
      -- start the command stack going
      command_stack_continue()
   end

   currently_running_p = true
   current_believed_location( end_location )
end



function command_stack_is_empty()
   return command_stack == nil or
      #command_stack == 0 
end

--
-- The command stack stores thoses commands that remain before the end of the
-- speedwalk. Do the next one. 
--
function command_stack_continue()
   
   -- we've got to the end, so signal this through the mud, so that the client
   -- knows when the mud has finished.
   

   if( command_stack_is_empty() ) then
      send_runend( "srunto" )
      return
   end
   
   -- pop the next step
   local next_step = table.remove( command_stack, 1 )
   
   -- next step is a special command, so signal this via the mud. 
   if( commands_specials[ next_step ] ) then
      send_runend( next_step )
   else
      -- just execute the command. 
      Execute( next_step )
      -- and recurse
      command_stack_continue() 
   end
end

--
-- we can mark a location, so that we can return to it later
--
local marked_location = nil
function mark()
   marked_location = last_known_location()
   sprint( "Marking Location: ", location_print_string( marked_location ) )
end

function mark_return()
   if( marked_location ) then 
      runto_location( marked_location )
   else
      runto_location( get_recall_location() )
   end
end

--
-- print the path to a given location from current
-- 
function showpath( name, line, wildcards )
   sprint( "showpath" )
   
   local from, to = nil
   local splt = split( wildcards[ 1 ], " " )
   local locn1 = get_location_for_name( splt[ 1 ] )
   local locn2 = get_location_for_name( splt[ 2 ] )

   if( splt[ 2 ] and not locn2 ) then
      print( "Location now known:", splt[ 2 ] )
      return
   end
   
   if( splt[ 1 ] and not locn1 ) then 
      print( "Location not known:", splt[ 1 ] )
      return
   end

   if( locn1 and not locn2 ) then
      from = current_believed_location()
      to = locn1 
   end
   
   if( locn1 and locn2 ) then
      from = locn1 
      to = locn2 
   end

   
   -- print( "From:" )
   -- print_location( current_believed_location )
   -- print( "To:" )
   -- print_location( destination )

   
   print( "Path is:" )
   
   local final_direction, total_distance = shortest_path_to_string_impl( from,
                                                         to, true )
   
   

   
   print( "Complete Route:", final_direction )
   print( "Complete Distance:", total_distance )
   sprint( "showpath complete" )
end

--
-- turn the shortest path to a list
--
function shortest_path_to_list( start, finish, print_p )
   local path = shortest_path_to_string_impl( start, finish, print_p )

   print( "shortest_path_to_list", path )
   
   local split_values = split( path, ";" )
   return split_values
end

--
-- return the shortest path as a string. 
--
function shortest_path_to_string_impl( start, finish, print_p )
   
   local final_direction = direction_new()
   local total_distance = 0
   
   local path = shortest_path( start, finish )
   
   for i = 1, #path - 1, 1 do
      local distance, route_or_portal = shortest_direct_path( path[ i ], path[ i + 1 ] )
      total_distance = total_distance + distance
      
      local direction_string = ""
      if( route_or_portal.type == "portal" ) then
         direction_string = route_or_portal.alias
         table.insert( final_direction, direction_string )
      else
         direction_string = direction_to_speedwalk_string( route_or_portal.direction )
         for _, v in ipairs( route_or_portal.direction ) do
            table.insert( final_direction, v )
         end
      end
      
      -- bit ugly but might as well do this here..
      if( print_p ) then
         local path1 = location_print_string( path[ i ] )
         local path2 = location_print_string( path[ i + 1 ] )

         print( path1, " -> ", path2, 
                "Dir:", direction_string, "Dis:", distance )
      end
   end
   
   return direction_to_speedwalk_string( final_direction ), total_distance
end

--
-- print the run history 
--
function runhist( name, line, wildcards )
   for _, v in ipairs( runhistory )
   do
      print ( v )
   end
end

-- 
-- print the places we have runto
--
function runtohist( name, line, wildcards )
   for _, v in ipairs( runtohistory )
   do
      print ( v )
   end
end

--
-- we are not where we are supposed to be, 
--
function incorrect_location( name, line, wildcards )
   last_known_loc = current_believed_location()
   print( "Setting last known loc", 
          location_print_string( last_known_loc ) )
   
   current_believed_location( get_unknown_location() )
end

-- 
-- an speedwalk error has happened, so stop
function process_error( name, line, wildcards )
   print( "Srun process error" )
   runto_error = true
end

-- 
-- responses to the end of an runto command which is signalled via the mud.
--
function runtoend( name, line, wildcards, styles )
   
   -- there was a problem during the runto command, so we need to stop
   -- immediately, and try and guess where we are, based on the current room
   -- name.
   if( runto_error ) then
      runto_error = false
      commands_remaining_after_pause = nil
      guess( "guesscommand" )
      currently_running_p = false
      return
   end
   
   BroadcastPlugin( 1, runtohistory[ #runtohistory ] )

   -- 
   -- the plugin has been told to wait till the mud has caught up, so now we
   -- can carry on.
   if( wildcards[ 1 ] == "wait" ) then
      print( "Continue after wait" )
      command_stack_continue()
   end

   -- run a no-op -- this also cause a wait, but is silent
   if( wildcards[ 1 ] == "nop" ) then 
      -- print( "Srun nop" )
      command_stack_continue() 
   end

   
   -- 
   -- the plugin has been asked to pause, so say how much remains and stop.
   if( wildcards[ 1 ] == "pause" ) then 
      if( #command_stack > 0 ) then 
         sprint( "Pausing srun -- srun continue to restart" )
         print( #command_stack .. " command(s) remain in queue" )
      end
   end

   -- the plugin has been asked to pause for an automaze
   if( wildcards[ 1 ] == "autohuntpause" ) then
      if( #command_stack > 0 ) then 
         sprint( "Pausing srun for autohunt. Restart on autohunt complete" )
         print( #command_stack .. " command(s) remain in queue" )
      end
   end

   -- the plugin has been asked to pause for an automaze
   if( wildcards[ 1 ] == "automazepause" ) then
      if( #command_stack > 0 ) then 
         sprint( "Pausing srun for automaze. Restart on automaze complete" )
         print( #command_stack .. " command(s) remain in queue" )
         Execute( "automaze" )
      end
   end

   
   -- we've finished a runto command mediated by this plugin. s
   if( wildcards[ 1 ] == "srunto" ) then
      sprint ("runto complete" )
      
      -- are their commands remaining? If so, do the next one of these
      -- and wait for it to finish
      
      -- all commands are done, so grab mud details if needed
      if( not current_believed_location().title ) then 
         commands_remaining_after_pause = nil
         grab_mud_location_details( current_believed_location() )
      end
      currently_running_p = false
   end
   
   -- we've finished a runto command from the mud. 
   if( wildcards[ 1 ] == "sysrunto" ) then 
      
      sprint( "Ending mud runto command" )
      -- we should now where we were going...
      local current_location = get_runto_names()[ current_running_to_formal_title ]
      
      if( not current_location ) then
         print( "Location is unknown:", current_running_to_formal_title )
         incorrect_location()
         return
      end
      -- does current location have any proper info in it? 
      if( not current_location.title ) then 
         grab_mud_location_details( current_location )
      end
      
      current_believed_location( guess_location() )
      
      local at_unknown = current_believed_location() == get_unknown_location()
      
      if( not at_unknown ) then
         local location, runto = 
            add_runto_name( current_believed_location(), 
                            runtohistory[ #runtohistory ] )
         print( "Added:", runto, "as shortcut for: ", location.area )
      end
      sprint( "mud runto complete" )
      currently_running_p = false
   end
end


--
-- apply the details of the location from the mud to the current location
-- stored by the plugin.
--
function grab_mud_location_details( location )
   location.title = roomname 
   location.x = coord.x 
   location.y = coord.y
   location.zone = coord.zone

   print( "New details discovered" )
   print_location( location )
   print() 
end

--
-- Grab speedwalks from the mud. 
--
local lines_processed = 0

function read_speedwalk( name, line, wildcards )
   EnableTrigger( "start" )
   Execute( "pagesize 0;echo {speedwalkstart};speedwalks;areas keywords;echo {speedwalkend};pagesize 24" )
   lines_processed = 0
end

function speedwalk_redirect( name, line, wildcards, styles )
   -- it's the start redirect
   if( name == "start" ) then
      EnableTrigger( "line", true )
      get_srun_info().speedwalk = {}
      return
   end
   
   -- we are at the end, so stop
   if( string.match (line, "{speedwalkend}" ) ) then
      EnableTrigger ("line", false)  -- no more lines to go
      EnableTrigger ("start", false)  -- don't capture again
      
      sprint( "Read ", lines_processed, " speedwalks and area lines" )
      
      clear_conf()
      
      return
   end
   lines_processed = lines_processed + 1
   table.insert( get_srun_info().speedwalk, line )
end

function add_speedwalk_line( line )
   -- it's a keyword line, so add the keywords
   _, _, keyword, area = line:find( "%s*%d+%s+%d+%s+%d*%s+(%a*)%s+(%a*.*)" )
   if( keyword and area ) then
      area = trim( area )
      local location = get_location_for_name( area )
      add_runto_name( location, keyword )
      return
   end
   
   -- it's a speedwalk line so add the new direction
   area, direction = process_speedwalk_command_output_line( line )
   if( area ) then
      local tolocation = location_new()
      tolocation.area = area
      tolocation.mud_speedwalk = direction

      add_direction ( get_recall_location(), 
                      direction, tolocation ) 
      add_runto_name( tolocation, tolocation.area )
      
      -- iwuvaard takes "the" off, which means that I miss half the
      -- speedwalks. This enables them again. It's a useful thing to have anyway. 
      if( tolocation.area:sub( 1, 4 ) == "The " ) then
         add_runto_name( tolocation, tolocation.area:sub( 5 ) )
      end
   end
end


-- 
-- run from "srun continue" 
-- Move on to the next item after a pause
--
function continue_alias( name, line, wildcards )
   sprint( "Continue after pause" )
   command_stack_continue()
end

-- 
-- we have paused in response to automazepause; automaze has now finished so we can carry on. 
-- 
function automaze_continue( name, line, wildcards )
   if( not command_stack_is_empty() ) then 
      sprint( "Continue after automaze" )
      command_stack_continue()
   end
end


function autohunt_continue( name, line, wildcards )
   if( not command_stack_is_empty() ) then 
      sprint( "Continue after autohunt" )
      command_stack_continue()
   end
end

-- delete and list commands
function list_alias( name, line, wildcards ) 
   local splt = split( wildcards[ 1 ], " " )
   
   if( splt[ 1 ] == "location" ) then
      sprint( "Known Locations:" ) 
      list_impl( srun_info.locations )
   end

   if( splt[ 1 ] == "portal" ) then
      sprint( "Known Portals:" ) 
      list_impl( srun_info.portals )
   end

   if( splt[ 1 ] == "direction" ) then
      sprint( "Known Directions:" )
      list_impl( srun_info.directions )
   end

end


function list_impl( tble )
   for i,v in pairs( tble ) do
      print( i, string_from_table_or_string( v ) )
   end
end

function string_from_table_or_string( thing )
   if( type( thing ) == "table" ) then 
      return table.concat( thing, " " )
   end

   return thing
end

function delete_alias( name, line, wildcards )
   local splt = split( wildcards[ 1 ], " " )
   
   local index = tonumber( splt[ 2 ] )
   
   if( splt[ 1 ] == "location" ) then
      sprint( "Removing Location: " )
      delete_impl( srun_info.locations, index )
   end

   if( splt[ 1 ] == "portal" ) then
      sprint( "Removing Portal: " )
      delete_impl( srun_info.portals, index )
   end

   if( splt[ 1 ] == "direction" ) then 
      sprint( "Removing Direction:" )
      delete_impl( srun_info.directions, index )
   end

end


function delete_impl( tble, index )
   print( string_from_table_or_string( tble[ index ] ) )
   table.remove( tble, index )
   clear_conf()
end

--
-- These are the commands that add new locations or routes to the system. The
-- "alias" functions just alter the info data, but does not generate the data
-- model that it used for the shortest path calculation, which the "command"
-- functions modify the underlying data model.
--

-- add a new location to the configuration
function add_location_alias( name, line, wildcards )
   sprint( "Adding Location" )
   local splt = split( wildcards[ 1 ], " " )
   
   local location_given_name = splt[ 1 ]
   local config = splt[ 2 ]
   
   local command = {}
   command[ 1 ] = location_given_name
   command[ 2 ] = config
   
   table.insert( get_srun_info().locations, command )
   
   clear_conf()
end

-- add the location to the core data structures. 
function add_location_command( location_given_name, config )
   -- location might already exist iff it is a speedwalk name, in which case,
   -- we just add config, if needed.
   local location = get_location_for_name( location_given_name )
   if( not location ) then
      location =     
         location_new()
      location.given_name = location_given_name
      add_runto_name( location, location.given_name )
   end

   
   if( config ) then 
      local opts = parseopts( config )
      
      if( opts.no_portal ) then 
         location.no_portal = true
      end
      
      if( opts.no_recall ) then 
         location.no_recall = true 
      end
   end
end

-- add a new portal
function add_portal_alias( name, line, wildcards )
   
   sprint( "Adding portal" )
   local splt = split( wildcards[ 1 ], " " )
   local portal_alias = splt[ 1 ]
   local location_string = splt[ 2 ]
   local config = splt[ 3 ]
   
   print( "portal", portal_alias, "location", location_string, "config", config )
   -- determine location
   if( location_string ) then 
      
      -- this forces reloading of configuration which makes adding lots of
      -- portals very slow. Would be nice to enable this, but the speedwalk
      -- and iwuvaard stuff is not parsed at this point.
      
      --if( not get_runto_names()[ location_string ] ) then 
      --   print( "Location not known: ", location_string )
      --   return
      --end
   else
      -- this forces reloading also...
      if( current_believed_location() == get_unknown_location() ) then
         print( "Current location unknown" )
         return
      end
      location_string = (current_believed_location().area_name or current_believed_location().given_name)
   end

   local command = {}
   command[ 1 ] = portal_alias
   command[ 2 ] = location_string 
   command[ 3 ] = config 

   table.insert( get_srun_info().portals, command )   

   clear_conf()
end

function add_portal_command( portal_alias, location_string, config )
   
   local location = get_runto_names()[ location_string ]
   local portal = nil
   
   local status, err = pcall( 
      function() 
         portal = add_portal( portal_alias, location )
      end )
   
   if( not status ) then 
      print( "There is a problem with this portal: ", portal_alias, location_string, config )
      print( err )
      return
   end
   
   -- local portal = add_portal( portal_alias, location )
   
   if( config ) then 
      local opts = parseopts( config )
      
      if( opts.level ) then 
         portal.level = tonumber( opts.level )
      end
      if( opts.distance ) then 
         portal.weight = tonumber( opts.distance )
      end
      if( opts.recall_type ) then
         portal.is_recall_type = true 
      end
   end
end

--
-- add direction to the configuration
--
function add_direction_alias( name, line, wildcards )
   sprint( "Adding direction" )
   
   local splt = split( wildcards[ 1 ], " " )
   local from = splt[ 1 ]
   local to = splt[ 2 ]
   local config = nil
   
   -- is the last item config
   local config_maybe = splt[ #splt ]
   print( "Config maybe", config_maybe )
   if( isopt( config_maybe ) ) then
      config = config_maybe
      
      splt[ #splt ] = nil
   end

   -- TODO 
   -- this forces reloading of the conf, which is not desirable here. 
   -- if( not get_location_for_name( from ) ) then
   --    print( "Location not known: ", from )
   -- end
   
   -- if( not get_location_for_name( to ) ) then
   --    print( "Location not known: ", to )
   -- end
   
   print( "Direction", from, to )
   
   -- do some rearrangements, so that we can pass in multi command things. In
   -- this case, replace ":" with ";" -- mushclient will interpret any ";" in.
   -- This is a bit ugly, but I can't think of a better way around it.
   
   -- first get rid of from and to. 
   table.remove( splt, 1 )
   table.remove( splt, 1 )
   
   -- not stick everything with a space back together again. 
   local sw = table.concat( splt, " " )
   
   -- now replace ":" with ";" 
   sw = string.gsub( sw, ":", ";" )
   
   print( "sw:", sw )
   print( "config:", config )
   
   local command = {}
   command[ 1 ] = from
   command[ 2 ] = to
   command[ 3 ] = sw
   command[ 4 ] = config
   
   table.insert( get_srun_info().directions, command )

   clear_conf()   
end

function add_direction_command( from_str, to_str, sw, config )
   
   local from = get_location_for_name( from_str )
   local to = get_location_for_name( to_str  )
   
   local direction = nil
   local status, err = pcall(
      function()
         direction = full_speedwalk_string_to_direction( sw )
      end )
   
   if( not status ) then 
      print( "There is a problem with parsing this direction: ", sw )
      print( err )
      error( err )
   end
   
   local route = nil
   local status, err = pcall( 
      function() 
         route = add_direction( from, direction, to )
      end )
   
   if( not status ) then 
      print( "There is a problem with this direction: ", from_str, to_str, sw )
      print( err )
      return
   end
   
   if( config ) then
      local opts = parseopts( config )
      if( opts.distance ) then
         route.distance = opts.distance
      end
   end
   
end


-- adding a run to 
function add_runto_alias( name, line, wildcards )
   sprint( "Adding runto name" )
   
   local splt  = split( wildcards[ 1 ], " " )
   local runto_name = splt[ 1 ]
   
   table.remove( splt, 1 )
   local location_title = table.concat( splt, " " )

   print( "runto", runto_name, "title", location_title )

   local command = {}
   command[ 1 ] = runto_name
   command[ 2 ] = location_title 
   table.insert( get_srun_info().runto, command )
   clear_conf()
end

function add_runto_command( runto_name, location_title )
   local location = get_runto_names()[ location_title ]
   
   add_runto_name( location, runto_name )
end



-- adding a route from clan recall really this should work through the normal
-- add direction, but it doesn't. The reason is that I need a default
-- direction which needs no configuration. It's a bit ugly from a user
-- perspective. In this case, there is just an alias -- it injects straight
-- into the serialisation variable (info) rather than the configuration.
function set_clan_recall_to_recall(name, line, wildcards)
   local splt = split( wildcards[ 1 ], " " ) 
   local direction = splt[ 1 ] 

   get_srun_info().clan_recall_to_recall = direction
   
   print( "Route from clan recall to recll set to ", direction )
   clear_conf()
end


function set_prerun(name, line, wildcards)
   local splt = split( wildcards[ 1 ], " " )
   local command = splt[ 1 ]
   
   get_srun_info().pre_run = command
   print( "Prerun command", command )
end


function pre_run()
   local rp = get_srun_info().pre_run
   -- this should only happen with an outdated srun_info
   if( not rp ) then
      rp = ""
   end

   return rp
end


function set_tier(name, line, wildcards)
   print( wildcards ) 
   local tier = tonumber( wildcards[ 1 ] )
   if( tier == nil or 
       tier < 0 or tier > 9 ) then 
      print( "Needs to be a number betweeen 1 and 9" )
      return
   end
   get_srun_info().tier = tier
   print( "Setting tier to:" , tier )
end

function tier()
   local tr = get_srun_info().tier
   if( not tr ) then 
      tr = 0
   end
   return tr
end

-- 
-- where will this command take me to?
-- 
function where( name, line, wildcards )
end


-- 
-- guess the current location 
-- 
function guess( name, line, wildcards )
   if( name == "guesscommand" ) then 
      SendNoEcho( "look" )
      SendNoEcho( "echo {srunguess}" )
      return
   end
   
   if( name == "guesstag" ) then
      local location = guess_location() 
      current_believed_location( location )
      print_current_location()
      return
   end
end

function guess_location()
   
   --print( "coord.x", coord.x, "co.y", coord.y, "co.zone", coord.zone,
   --       "roomname", roomname )
   
   for _, location in ipairs( get_locations() ) do
      --print( "location.x", location.x, "loc.y", location.y, "loc.zone", 
      --        location.zone, "loc.title", location.title )
      
      -- check the title
      if( location.title == roomname and 
          location.x == coord.x and 
          location.y == coord.y and
          location.zone == coord.zone and
          location.title == roomname ) then
         return location
      end
   end
   -- so we are lost
   return get_unknown_location()
end


function show_location( name, line, wildcards )
   print_current_location()
end


function room_change()
   local var = GetPluginVariableList(  "18c24130ab326dc05b49420d" )
   previousroomname = roomname
   roomname = var.roomname
   

   -- this code is still not ideal -- 
   if( 
      -- we are not running
         not currently_running_p and
         -- we are not unknown anyway
         not (current_believed_location() == get_unknown_location()) and
      -- room name has changed from the last time this is a bit dubious, but
      -- it should solve the problem of ending up in an unknown room after
      -- just looking
      not (roomname == previousroomname) )
   then
      -- probably too noisy, will change this eventually.
      sprint( "setting location unknown" )
      incorrect_location()
   end
end

function print_current_location()
   sprint( "Current Location" )
   print_location( current_believed_location() )
   sprint( "Complete" )
end

function print_location( location )
   local outr = count( location.outroutes )
   local inr = count( location.inroutes )
   local inp = count( location.inportals )
   
   print( "ID:", location.id )
   print( "Area name:", location.area )
   print( "Room title: ", location.title )
   print( "Given Name: ", location.given_name )
   print( "Coords:", location.x .. ",", location.y .. ",", location.zone )
   print( "There are", outr, "outgoing routes" )
   print( "There are", inr, "incoming routes" )
   print( "There are", inp, "portals ending here" )
end

--
-- All information
--
function srun_print( name, line, wildcards )
   local command = wildcards[ 1 ] 

   if( command == "datestamp" ) then 
      print( "Date stamp is", datestamp )
      return
   end
   
   if( command == "test" ) then 
      local distance, path = shortest_direct_path( get_recall_location(), 
                                                   get_location_for_name( "mesolar" ) )

      print( "Distance", distance )
      print( path )
      return
   end
   
   if( command == "unreachable" ) then 
      print( "Testing for reachability" )
      local recl = get_recall_location()
      local unreachable = {}
      for _, v in ipairs( get_locations() ) do
         local route, dist_matrix = shortest_path( recl, v )
         local distance = dist_matrix[ v ]
         print( location_print_string( v ), "length from recall", distance )
         if( distance == 0 ) then 
            table.insert( unreachable, v )
         end
      end

      for _, v in ipairs( unreachable ) do 
         print( location_print_string( v ), "is unreachable" )
      end

      return
   end


   if( command == "distance" ) then 
      print( "Testing for reachability" )
      local recl = get_recall_location()
      local unknown = get_unknown_location()
      local route, dist_matrix = shortest_path( recl, v )    

      local sorted = {}
      
      for _, v in ipairs( get_locations() ) do
         local distance = dist_matrix[ v ]
         table.insert( sorted, {v, distance})
      end
      
      table.sort( sorted, 
                  function(a,b)
                     return a[ 2 ] > b[ 2 ]
                  end )

      for _, v in ipairs( sorted ) do
         print( location_print_string( v[ 1 ] ), " length from recall ", 
                v[ 2 ] )
      end
      
      return
   end
   
   if( command == "direct" ) then 
      print( "Shortest direct path" )
      
   end
   
   if( command == "runto" ) then
      print( "runto names" )
      for i, v in pairs( get_runto_names() ) do
         print( i, v.area )
      end
      return
   end
   
   if( command == "location" ) then 
      print( "Location ID", "Location Name" )
      
      local locations = get_locations() 
      for k, v in ipairs( locations ) do
         print( k, v.area )
      end
      return
   end
   
   if( command == "current" ) then
      print_current_location()
      return
   end
   
   if( command == "routes" ) then 
      print( pretty_location_routes( current_believed_location() ) )
      return
   end
   
   if( command == "portals" ) then 
      local portals = current_believed_location().inportals
      for _, v in pairs( portals ) do
         print( "Portal Alias:", v.alias, 
                "Weight:", v.weight )
      end
      return 
   end 
   
   if( command == "all" ) then 
      print( pretty_location_routes( get_recall_location() ) )
      return
   end
   
   if( command == "dot" ) then 
      print( dot_string() )
      return
   end
   print( "Don't know how to print:", command )   
end

function count( hash )
   local count = 0
   for _, _ in pairs( hash ) do count = count + 1 end
   return count
end

function clearall( name, line, wildcards )
   sprint( "Clearing all" )
   srun_config = nil
   srun_info = nil
   
   read_speedwalk()
end

function dumpinfo()
   sprint( "Dump Info" )
   print( serialize.save( "srun_info", get_srun_info() ) )
   sprint( "Complete" )
          
end

function dumpall( name, line, wildcards )
   sprint( "Dump All" )
   print( serialize.save( "srun_config", get_srun_config() ) )
   print( serialize.save( "srun_info", get_srun_info() ) )
   sprint( "Complete" )
end

-- 
-- triggers
--
function portal_use ( name, line, wildcards, styles )
   -- need to disable this when I know where the portal is going. 
   -- guess_location()
end

-- this function runs only when "{coords}-1" is detected, which should be
-- specific to the aardh.
function updatelocation_aardh (name, line, wildcards, styles)
   coord.x = -1
   coord.y = -1 
   coord.zone = -1
end

function updatelocation (name, line, wildcards, styles )
   coord.x = tonumber (wildcards.x) 
   coord.y = tonumber (wildcards.y)
   coord.zone = tonumber (wildcards.zone)
end 

function running_to( name, line, wildcards, styles )
   current_running_to_formal_title = wildcards[ 1 ]
end

--
-- subsidiary function
--
function sprint(...)
   local arg = {...}
   
   local print = ""
   for _,v in pairs( arg ) do
      print = print .. v
   end
   ColourNote( "white", "green", "Srun: " .. print )
end

function OnShortHelp()
   print( "Srun shortest path plugin.")
   print( "srun help for more information" )
end


function OnPluginBroadcast( msg, id, name, text )
   -- exits detector
   if ( id == "18c24130ab326dc05b49420d" ) then
      if ( msg == 1 ) then
         room_change()
      end
   end

   -- automaze
   if( id == "21c24130ab326dc05b49420d" ) then
      if ( msg == 1 ) then 
         automaze_continue()
      end
   end
   
   
   if( id == "19c24130ab326dc05b49420d" ) then
      if ( msg == 1 ) then 
         autohunt_continue()
      end
   end

end

-- what level is the character at the moment
function whatlevel()
   local stats = GetPluginVariableList("8a710e0783b431c06d61a54c")
   return tonumber( stats["level"] )
end

-- what level equipment can the character use
function whateqlevel()
   return whatlevel() + tier() * 10
end


function parseopts(opt_string)
   local opts = {}
   local keyval = split( opt_string, "," )
   
   for _, v in pairs( keyval ) do
      local keythenvalue = split( v, "=" )
      if( not keythenvalue[ 2 ] ) then
         -- for value less options
         keythenvalue[ 2 ] = 1
      end
      opts[ keythenvalue[ 1 ] ] = keythenvalue[ 2 ]
   end
   return opts
end


function isopt(opts)
   return (string.match( opts, "," ) or
        string.match( opts, "=" ))
   and not string.match( opts, " " )
end

-- this code is partly derived from pseudocode on wikipedia and partly from an
-- implementation of this, on the lua mailing list. Wikipedia is under the Gnu
-- Free Documentation License. The implementation on the lua mailing list was
-- public domain I guess.

-- implements a shortest path calculator over the srun_graph data structures.
-- On my machine, this will do 1000 random nodes with a 1/20 chance of a route between 
-- in a second or so

local INF = 1/0 

-- This is the slow bit in the code, being a linear search through all the
-- remaining nodes.
local extract_min = function(Q, d)
                       
                       -- m is the shortest distance
                       local m = INF
                       -- i is the current shortest node
                       local i = nil
                       -- iterate through Q
                       for v, _ in pairs( Q ) do
                          --  <= ensures that this will succeed at least once,
                          -- even for disconnected nodes, therefore ensuring
                          -- that i cannot remain nil. Actually someone could
                          -- give a disance of NaN, but that's just asking for
                          -- trouble.
                          if d[v] <= m then
                             m = d[v]
                             i = v
                          end
                       end
                       
                       Q[ i ] = nil -- remove i
                       return i
                    end



function dijkstra (start, finish)
   
   -- d is the distances from start to each node in turn. This is a hash keyed
   -- on a location, valued on, well, the distance. 
   local dist = {}
   local previous = {}
   
   nQ = 0

   -- for each vertex v, set the unoptimized distance to infinity
   for _, v in ipairs( get_locations() ) do
      nQ = nQ + 1
      dist[v] = INF 
   end
   
   -- distance from start to start is zero
   dist[start] = 0
   
   
   -- Q is those nodes which have not been optimized for yet. which is just a
   -- local copy of the locations, as Q is used destructively.
   local Q = {}
   for i, v in ipairs( get_locations() ) do 
      Q[ v ] = 1
   end -- fill Q
   
   while nQ > 0 do
      
      -- u is the mode in Q which is closest to the current node, Q being the
      -- unoptimized ones.
      local u = extract_min(Q, dist)
      

      -- fast termination where we know the finish node
      if( u == finish ) then 
         return dist, previous
      end
      
      nQ = nQ - 1
      for _, v in ipairs( get_locations() ) do
         
         -- if there is an edge between u and v
         local edge_distance = shortest_direct_path( u, v )
         
         if( edge_distance and 
             dist[v] > dist[u] + edge_distance ) then
            dist[v] = dist[u] + edge_distance
            previous[v] = u
         end
      end
   end
   return dist, previous
end

-- returns the shortest direct path and distance between two locations. 
function shortest_direct_path( fromlocation, tolocation )
   local edge = fromlocation.outroutes[ tolocation.id ]
   local portals = tolocation.inportals
   
   -- Aaaaaaaaahhhh!
   -- this function is terrible. 
   local shortest_portal_or_edge = nil
   local shortest_distance = nil
   
   -- TODO I'm starting to think that this is too complex and too aard
   -- specific for here. Perhaps it should be in the calling function.
   -- 
   -- The location that we are when we move. This is probably the from
   -- location, unless it's the unknown location, in which case it's our best
   -- guess at the last location, as this is most likely to have the correct
   -- no_portal/no_recall information.
   local current_location = fromlocation
   if( fromlocation == get_unknown_location() ) then
      current_location = last_known_location() 
   end

   -- are we in a no portal location. 
   -- 
   -- current location might also be unknown,
   -- so look at the last known location.
   local is_no_portal_area = current_location.no_portal
   local is_no_recall_area = current_location.no_recall
   
   
   for i, v in ipairs( portals ) do
      -- need also to check if the room is no portal need to differentiate
      -- between no portal and no recall.
      if( not (is_no_recall_area and v.is_recall_type) ) then 
         
         if( (not is_no_portal_area) or
          v.is_recall_type ) then

            -- is the portal low enough level to be usable.
            if( v.level <= whateqlevel() ) then 
               if( (not shortest_portal_or_edge) or
                shortest_portal_or_edge.weight > v.weight ) then
                  shortest_portal_or_edge = v
                  shortest_distance = v.weight
               end
            end
         end
      end
   end
   

   if( edge ) then
      
      local edge_distance = #edge.direction
      
      -- if the edge distance is explicit then use that
      if( edge.distance ) then
         edge_distance = tonumber( edge.distance )
      end
      
      
      
      if( (not shortest_portal_or_edge) or 
       shortest_distance > edge_distance ) then
         shortest_portal_or_edge = edge 
         shortest_distance = edge_distance
      end
   end 

   --print( "frml", fromlocation.title, "tol", tolocation.title, 
   --"sht_dis", shortest_distance, 
   --"sht_pl_or_ed", shortest_portal_or_edge )

   return shortest_distance, shortest_portal_or_edge
end

function path (previous, target)
   -- previous stores the routes, but backward, so we need to turn them around.
   local i = target
   local route = { i }
   while previous[i] do
      table.insert(route, 1, previous[i])
      i = previous[i]
   end
   
   return route
end


-- given a start location and a finish location, return all the locations as
-- an array. Through which we should travel to get to the finish by the
-- shortest route.
function shortest_path( start, finish )
   distance, previous = dijkstra( start, finish )
   route = path( previous, finish )
   
   return route, distance
end

reverse_dir = { n = "s", e = "w", s = "n", w = "e", u = "d", d = "u" }


function reverse_direction( direction )
   -- reverse direction
   local retn = {}
   -- the last door that we went through
   local last_door = nil
   
   for i = # direction, 1, -1  do
   
      thisdir = direction[ i ]
      -- we have a reversible door open command
      if( string.sub( thisdir, 1, 4 ) 
       and reverse_dir[ string.sub( thisdir, 6, 6 ) ] ) then 
         last_door = "open " .. 
            reverse_dir[ string.sub( thisdir, 6, 6 ) ]
         -- we need to insert this not last, but before last, as we need to
         -- open the door before the move.
         last = retn[ # retn ]
         table.remove( retn, # retn )
         table.insert( retn, last_door )
         table.insert( retn, last )
      else
         if( reverse_dir[ thisdir ] ) then 
            table.insert( retn, reverse_dir[ thisdir ] )
         else
            return false
         end
      end
   end
   return retn
end

iwuvaard_dirs = {
["Aardwolf Estates"] = "run d;run wunse4nen",
["Aardwolf Estates 2000"] = "run d;run 2s26en5e3n",
["Aardwolf Isle Estates"] = "run u29e",
["Aardwolf Zoological Park"] = "run d;run 2s14en",
["Adventurers Wayhouse"] = "run w3n3ws",
["Alagh, the Blood Lands"] = "run d;run 2s17e2s6en15e",
["All in a Fayke Day"] = "run un4wn7wd",
["Amazon Nation"] = "run e16sw",
["Amusement Park"] = "run d;run 1w2u",
["Ancient Greece"] = "run s7n11w",
["Antharia"] = "run n5swsw3se8s18ed",
["Arboria"] = "run d;run 6sds2end",
["Archipelago of Entropy"] = "run 14w8nd",
["Arisian Realm"] = "run w3n8e",
["Artificer's Mayhem"] = "run w2se2s4e5sw6sw5sen",
["Astral Travels"] = "run w2se2sw5s4e6s7e2su",
["Avian Kingdom"] = "run w2se2sw5s4e8s4eu",
["Black Rose"] = "run d;run 6sds2endenwn4wu",
["Call of Heroes"] = "run d;run 2n2w;open w;run 2wn;knock door",
["Canyon Memorial Hospital"] = "run n4s4e",
["Casino"] = "run d;run 2s4w3s3w;open south;s",
["Castle Reinhold"] = "run d;run wun8s2w3s",
["Castle Vlad-Shamir"] = "run 4e11se",
["Cataclysm"] = "run d;run 13s5ende2us",
["Chaprenula's Laboratory"] = "run d;run sws3wnewseseses2e6s",
["Chasm and The Catacombs"] = "run d;run 2s8eswnunuw",
["Chessboard"] = "run d;run 2s5es;watch game",
["Child's Play"] = "run d;run 4ne;op n;run 2nw12nwn",
["Christmas Vacation"] = "run n8e",
["Council of the Wyrm"] = "run 8e4ndwd6w2des2en2es2ene2dswn2ws4wn2wd3es2en2es2ene2s5d",
["Covenant of Mistridge"] = "run e24n5e",
["Cradlebrook"] = "Run e4n18w",
["Crystalmir Lake"] = "run d;run 2s10wn2wn9w3nw",
["Cthos Mishrak"] = "run 6e8n",
["Curse of the Midnight Fens"] = "run d;run wuesw8n15w",
["Dark Elf Stronghold"] = "run 3n17eu",
["Darkside of Dominia"] = "run d;run 4ne;op n;run 2nw10n8es2n;ent jet;run n",
["Deadlights"] = "run ws6w2nun2ununwn4u",
["Death's Manor"] = "run d;run wun9s",
["Deathtrap Dungeon"] = "run d;run 4ne;op n;run 2nw17n7en9e4n2e4d;op w;run 17w3sw5s2w;op w;run 3w2n",
["Den Of Thieves"] = "run d;run sws3wnwu4es",
["Descent to Hell"] = "run 8e4nd",
["Desert Doom"] = "run ew18n2wunu",
["Desert Prison"] = "run ew10n4wne",
["Diamond Soul Revelation"] = "run d;run sws3wnw",
["Dortmund"] = "run d;run 2s27e",
["Drageran Empire"] = "run w2se2sw2s3ws4w2n2w8s",
["Dragon Cult"] = "run d;run sws3wnwu8en",
["Dragon Mountain"] = "run w11s",
["Dragon Tower"] = "run d;run w2u11s2e",
["Dread Tower"] = "run d;run wuns6ws",
["Dungeon of Doom"] = "run e8s2wd",
["Dwarven Kingdom"] = "run d;run sws3wnwusw",
["Earth Plane 4"] = "run d;run sws3wnuse4n19e",
["Eighteenth Dynasty"] = "run d;run 4ne;op n;run 2nw17n7en4en3n;open d;run 4dws",
["Empire of Talsa"] = "run 17s2e;enter rope",
["Empire of the Tsuranuanni"] = "run u5s10wu;enter rift",
["Entrance to Hades"] = "run w2se2s4e3s2en",
["Eternal Autumn"] = "run w12e",
["Fabled City of Stone"] = "run d;run sws3w2nw2s4ed",
["Falcovnia"] = "run d;run 4ne;op n;run 2nw17n8wu",
["Fantasy Fields"] = "run d;run 2s8en5e3n;sleep",
["Flying Citadel"] = "run e7w6nd",
["Fort Terramire"] = "run d;run sws3wneu",
["Fortress of Angband"] = "run ws6w2nun2un2uwndn",
["Gallows Hill"] = "run d;run 33s2e3s",
["Gauntlet"] = "run d;run sws3wne7w3s",
["Gelidus"] = "run d;run 4ne2nw24n",
["Giant's Pet Store"] = "run d;run 2s14ene3n;open w;w;open w;run wsws",
["Gilda And The Dragon"] = "run d;run sws3wndnw4s",
["Gladiator's Arena"] = "run u27enu",
["Goblin Fortress"] = "run w2se2s4e5sw2s4e;open down;down",
["Goblin Path"] = "run d;run 4ne;op n;run 2nw19ne",
["Gold Rush"] = "run d;run wunsen4en",
["Grand City of Aylor: The Mob Barney"] = "run d;run 6s3e1s",
["Graveyard"] = "run d;run 2s17e2s7e",
["Great City of Knossos"] = "run s7n11w6se3nenwnd",
["Great Salt Flats"] = "run ew18n2wu",
["Halls of the Damned"] = "run w12wne",
["Helegear Sea"] = "run d;run sws3wnew3n11e3n",
["Highlands"] = "run d;run wue2s4wn3ws",
["Icy Caldera of Mauldoon"] = "run ns9ws",
["Imperial City of Reme"] = "run e7n16w",
["Infestation"] = "run d;run 2s8e6n",
["Insanitaria"] = "run e10w10n6w6n",
["Into the Long Night"] = "run w2se2s4e5sw6sw5s5wd",
["Island of Lost Time"] = "run d;run sws3wnwu6w3n",
["Island of Stardock"] = "run s10en;enter mandala",
["Isle of Quake"] = "run d;run sws3wnews11en",
["Jenny's Tavern"] = "run w2nwn2ws;open s;run 2s2eu3w;open n;n;enter portal;open east;e",
["Jungles of Verume"] = "run d;run sws3w2n",
["Kerofk"] = "run d;run sws3wnew4s",
["Killing Fields"] = "run e5n",
["Kingdom of Ahner"] = "run d;run wun8s3e",
["Kul Tiras"] = "run 2w16s5w",
["Labyrinth"] = "run d;run sws3wne4w7s",
["Land of Dominia"] = "run d;run 4ne;op n;run 2nw10n8es",
["Land of Legend"] = "run d;run 4ne;op n;run 2nw2ne",
["Land of Oz"] = "run d;run sws3wnwu3nw",
["Land of the Beer Goblins"] = "run d;run w2u7sw",
["Land of the Fire Newts"] = "run d;run 4ne;op n;run 2nw12n10e",
["Lost City of Atlantis"] = "run s6n3es",
["MYST"] = "run w2se2sw2s3ws6w5s4w",
["Magical Hodgepodge"] = "run d;run 4ne;op n;run 2nw8ne4n2ese2w4n",
["Marshlands of Agroth"] = "run d;run 22sunus5w5n",
["Masquerade Island"] = "run wn2w3nwnw5nwn3wn2wnw15n",
["Mirror Realm"] = "run d;run 4ne;op n;run 2nw10n8es2ne",
["Misty Shores of Yarr"] = "run s8n17e",
["Monastery"] = "run d;run 2s27e8wne",
["Mountains of Desolation"] = "run ws6w",
["Nanjiki Ruins"] = "run e16swes4eses",
["Necromancers' Guild"] = "run d;run 2s17e2s8es2e5ses;open s;run 3s",
["New Thalos"] = "run s15n4w",
["Northstar"] = "run d;run 2s14e12s2wndu9n9wu",
["Nottingham"] = "run d;run sws3w2nw4s2e",
["Old Cathedral"] = "run d;run 2s27e10w",
["Old Thalos"] = "run d;run wun8se6s6e5sw",
["Olde Worlde Carnivale"] = "run d;run 2s8e2s",
["Onslaught of Chaos"] = "run d;run 2s8eswnunusen2ws",
["Oradrin's Chosen"] = "run u15e10n17e",
["Paradise Lost"] = "run d;run sws3wnus5w6s",
["Peaceful Giant Village"] = "run ws6w3n",
["Pirate Ship"] = "run d;run wue4neu",
["Pompeii"] = "run s7ne",
["Port"] = "run d;run 2s8eswnunus",
["Prison"] = "run d;run 13s5ende2un",
["Qong"] = "run uwn16wn4wu",
["Raganatittu"] = "run d;run sws3w2nw3n3e",
["Ranger Heaven"] = "run e2s8wu",
["Realm of Evil Heroes"] = "run d;run 2s26en14e2s3e;open d;run dw3n3es;open s;s;open s;run 2s;open w;run 3w",
["Realm of the Zodiac"] = "run w21s",
["Reman Conspiracy"] = "run d;run 2s26en14e2s3e;open d;run dw",
["River of Despair"] = "run d;run 2s17e5se",
["Rokugan, The Shadowlands"] = "run e3swe",
["Ruins of Diamond Reach"] = "run n11s2e",
["S.S. Hook: Siren's oasis resort"] = "run d;run wuns3e6n3e",
["Sanctity of Eternal Damnation"] = "run n6w3n5wd",
["Scarred Lands"] = "run d;run 8sunwds",
["School of Horror"] = "run 2w4nw9n",
["Seven Wonders"] = "run s7n11w6swn",
["Shadar Logoth"] = "run d;run 4ne;op n;run 2nw21n16wswsws2w3s2eu",
["Shadows of Minos"] = "run es17w",
["Shayol Ghul"] = "run d;run 2s10wn2wn4wn8wn14w9s11w4s3w4swu",
["Silver Volcano"] = "run 4w2s",
["Slaughter House"] = "run d;run 6suense11n",
["Snuckles Village"] = "run d;run 32s13e",
["Soulblade"] = "run d;run 2s10wn2wn4wn8wn14w9s11w5sw",
["Stonekeep"] = "run 10w4s;enter shaft",
["Storm Mountain"] = "run d;run sws3wnu",
["Sundered Vale"] = "run s4nw15n",
["Swordbreaker's Hoard"] = "run n12w",
["Tai'rha Laym"] = "run w3s2e",
["Takeda's Warcamp"] = "run 2e23n",
["Temple of Shal'indrael"] = "run d;run wunsws",
["Temple of Shouggoth"] = "run es4e",
["Temple of the White Lotus"] = "run d;run sws3wne3w2s",
["Three Pillars of Diatz"] = "run d;run 2s8eswnun2u",
["Tir na nOg"] = "run u8w4n",
["Touchstone Cavern"] = "run d;run 13s5en",
["Tournament Camps"] = "run d;run 2s9e3sw2s",
["Tournament of Illoria"] = "run w11n7e",
["Town of Solace"] = "run d;run wun",
["Tree of Life"] = "run d;run wuns3e7nu",
["Uncharted Oceans"] = "run d;run 33s31w10s",
["Unearthly Bonds"] = "run d;run 6sueu",
["Verdure Estate"] = "run d;run wun8se6s6e5sw2s4w3s2wnen",
["Vidblain, the Ever Dark"] = "run d;run 4ne;op n;run 2nw16n25e;enter hole",
["War of the Wizards"] = "run d;run sws3wnd",
["Wedded Bliss"] = "run d;run wun8se4s3e",
["Were Wood"] = "run e20sw",
["Wobbly Woes of Woobleville"] = "run d;run 6sued",
["Wood Elves of Nalondir"] = "run e3n21w",
["Xyl's Mosaic"] = "run wn2w2n5w3n4w7n",
["Yggdrasil: The World Tree"] = "run d;run 6sueun2wn6w16nu",
["Yurgach Domain"] = "run d;run 8sunwde",
["Zangar's Demonic Grotto"] = "run d;run 2s8eswnunuw4d;open west;run wds2wnwd3wsdswnw;open down;run desesd2wd",
}
-- speedwalks that we know are wrong and want to block
local knowniwuvaardblock = 
   {
   ["Jungles of Verume"] = 1,
   ["Storm Mountain"] = 1 ,
   ["Diamond Soul Revelation"] = 1,
   ["UnderDark"] = 1,
   ["Land of Oz" ] = 1,
   ["Vidblain, the Ever Dark" ] = 1,
   ["Isle of Quake" ] = 1,
   ["Fort Terramire" ] = 1,
   ["Kerofk"] = 1,
   ["Chaprenula's Laboratory"] = 1,
   ["Temple of the White Lotus"] = 1,
   ["Highlands"] = 1,
   ["UnderDark"] = 1, -- 09-03-28
   ["New Thalos"] = 1, 
   ["Gilda And The Dragon"] = 1, -- 09-09-10
   ["Gauntlet"] = 1,
   ["Helegear Sea"] = 1,
   ["Fort Terramire"] = 1,
   ["Dwarven Kingdom"] = 1,
   ["Labyrinth"] = 1,
   ["Raganatittu"] = 1,
   ["Paradise Lost"] = 1,
   ["Earth Plane 4"] = 1,
   ["Cradlebrook"] = 1,
}


function get_blocked_locations()
   local blocked = {}

   for i, v in pairs( get_srun_info().iwuvblock ) do
      blocked[ v ] = 1
   end

   for i, v in pairs( knowniwuvaardblock ) do
      blocked[ i ] = 1
   end
   
   return blocked
end


function iwuvaard_block( name, line, wildcards ) 
   local locn = wildcards[ 1 ]
   
   if( iwuvaard_dirs[ locn ] ) then 
      sprint( "Adding block on iwuvaard direction:", locn )
      table.insert( get_srun_info().iwuvblock, locn )

      clear_conf()
   else
      sprint( "Iwuvaard direction unknown:", locn )
   end

end

function iwuvaard_init ( name, line, wildcards )
   
   local aardh = get_aardh_location()
   local directions = 0
   local blocked_locations = get_blocked_locations()

   for i, v in pairs( iwuvaard_dirs ) do
      
      if( blocked_locations[ i ] ) then
         print( "Ignoring iwuvaard dir: ", i )
      else
         
         local direction = full_speedwalk_string_to_direction( v )
         local to = get_location_for_name( i )
         
         if( to == nil ) then 
            print( "Location unknown: ", i )
         else 
            local status, error  =
               pcall(function()
                        add_direction( aardh, direction, to ) 
                     end)
            
            if( not status and 
                error == "adding two directions which are the same" ) then
               print( "ignoring duplicate direction", i, v )
            else
               directions = directions + 1
            end
         end
      end
      
   end

   if( directions > 0 ) then 
      sprint( "Added ", directions, " new directions" )
   end
end

-- 
-- My original plan was to serialize the whole storage structure, but it
-- doesn't work because the serialized structure is much too large. Instead,
-- now, I am going to serialize the commands that have been given. Then,
-- recreate the main storage structure everytime this changes.
--
-- This should also have the advantage that we can store provenance, so we
-- know which internal directions came from which command, and make it easier
-- to remove directions. 
-- 
srun_info = nil
srun_info_version = 1

function get_srun_info()
   if( not srun_info ) then
      srun_info = {}
      
      -- version checker.
      srun_info.version = srun_info_version
      
      -- list of all the speedwalks read from the mud
      srun_info.speedwalk = {}

      -- list of all added (not speedwalk!) locations
      srun_info.locations = {}
      
      -- list of list runto commands from the client 
      srun_info.runto = {}

      -- list of list portals commands
      srun_info.portals = {}
      
      -- list of directions; a list of lists. Each sublist is "from", "to",
      -- direction string.
      srun_info.directions = {}

      -- list of blocked iwuvaard locations
      -- these are full names
      srun_info.iwuvblock = {}

      -- direction from clan recall to recall
      srun_info.clan_recall_to_recall = nil
      
      -- pre-run command, executed before every run
      srun_info.pre_run = ""

      -- tier
      srun_info.tier = 0
   end
   
   return srun_info
end

function rebuild_conf()
   sprint( "Rebuilding configuration" )
   
   for _, v in ipairs( get_srun_info().speedwalk ) do
      add_speedwalk_line( v )
   end
   
   for _,v in ipairs( get_srun_info().locations ) do
      -- if it's a string, we have an old config -- this just switches it over
      -- to being a table instead
      if( type( v ) == "string" ) then
         local tempv = {}
         tempv[ 1 ] = v
         v = tempv
      end
      
      add_location_command( v[ 1 ], v[ 2 ] )
   end
   
   for _,v in ipairs( get_srun_info().portals ) do
      add_portal_command( v[ 1 ], v[ 2 ], v[ 3 ] )
   end

   for _,v in ipairs( get_srun_info().directions ) do
      add_direction_command( v[ 1 ], v[ 2 ], v[ 3 ], v[ 4 ] )
   end
   
   for _,v in ipairs( get_srun_info().runto ) do
      add_runto_command( v[ 1 ], v[ 2 ] )
   end
   


   iwuvaard_init()
   sprint( "Rebuilding configuration complete" )
end

--
--  check function 
--
function check_info_version()
   return get_srun_info().version == srun_info_version
end


--
-- Plugin handlers
--
function OnPluginSaveState()
   -- save state, by dumping into mushclient var which then serialize it.
   var.srun_info = serialize.save( "srun_info", get_srun_info() ) 
end

function OnPluginInstall()
   checkplugin( "18c24130ab326dc05b49420d", "Aardwolf_exits_detector.xml" )
   
   
   -- OnHelp()
   if( var.srun_info ) then
      loadstring( var.srun_info )()
      
      if( not check_info_version() ) then
         sprint( "The saved graph structure appears to be different from that" )
         sprint( "expected by the current version of the srun plugin." )
         sprint( "Deleting the graph with srun clearall is probably necessary" )
      else
         -- to do -- should probably remove this later.
         sprint( "Graph Structure check complete" )
      end
   end

   if( #get_srun_info().speedwalk == 0 ) then
      read_speedwalk()
   end
   
   guess( "guesscommand" )   
end 





-- there are still quite a few bugs, but it's nearly there I think. 

-- need to add a "clear" command, to remove player added stuff (ignoring speedwalks). 
-- need to add a "refresh" to pull down speedwalks. 
-- need to change travel.lua srun_conf to just clear and add my stuff. 

-- there is a reasonable chance this should be it.]]>
</script>
</muclient>
